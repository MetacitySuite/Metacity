window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "metacity", "modulename": "metacity", "type": "module", "doc": "<p>Metacity is a library for creating and manipulating city objects. It supports the following formats: GeoJSON and Shapefile. City objects are represented as an array of objects, each of which has a set of properties. The properties include a geometry, and a set of metadata. The appearance of the city objects is defined by a set of styles. The styles are specified with a custom language. The library is designed to be extensible, so that new types of objects and styles can be added.</p>\n\n<p>Modules:</p>\n"}, {"fullname": "metacity.core", "modulename": "metacity.core", "type": "module", "doc": "<p></p>\n"}, {"fullname": "metacity.core.legofy", "modulename": "metacity.core.legofy", "type": "module", "doc": "<p></p>\n"}, {"fullname": "metacity.core.legofy.legofy", "modulename": "metacity.core.legofy", "qualname": "legofy", "type": "function", "doc": "<p>Generate lego tiles from a project. The lego tiles are generated in the output directory, stores json and png with heightmap.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>project (str):</strong>  The project to generate lego tiles from.</li>\n<li><strong>output_dir (str):</strong>  The directory to write the lego tiles to.</li>\n<li><strong>start (Tuple[float, float]):</strong>  The start coordinates of the lego tiles.</li>\n<li><strong>end (Tuple[float, float]):</strong>  The end coordinates of the lego tiles.</li>\n<li><strong>coordinates_decimal_precision (int):</strong>  The number of decimal places to round the coordinates to.</li>\n<li><strong>box_filter_size_range (Tuple[int, int]):</strong>  The range of box filter sizes to use.</li>\n<li><strong>box_filter_step (int):</strong>  The step size of the box filter.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(\n    output_dir: str,\n    start: Tuple[float, float],\n    end: Tuple[float, float],\n    coordinates_decimal_precision=2,\n    box_filter_size_range=(5, 45),\n    box_filter_step=5\n)", "funcdef": "def"}, {"fullname": "metacity.datamodel", "modulename": "metacity.datamodel", "type": "module", "doc": "<p></p>\n"}, {"fullname": "metacity.datamodel.datastore", "modulename": "metacity.datamodel.datastore", "type": "module", "doc": "<p></p>\n"}, {"fullname": "metacity.datamodel.datastore.layer_main_file", "modulename": "metacity.datamodel.datastore", "qualname": "layer_main_file", "type": "function", "doc": "<p>Get the main file of the layer.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>layer_dir (str):</strong>  The directory path of the layer.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>str: Path to the main file of the layer.</p>\n</blockquote>\n", "signature": "(layer_dir: str)", "funcdef": "def"}, {"fullname": "metacity.datamodel.datastore.layer_layout_file", "modulename": "metacity.datamodel.datastore", "qualname": "layer_layout_file", "type": "function", "doc": "<p>Get the main file of the layer.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>layer_dir (str):</strong>  The directory path of the layer.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>str: Path to the main file of the layer.</p>\n</blockquote>\n", "signature": "(layer_dir: str)", "funcdef": "def"}, {"fullname": "metacity.datamodel.datastore.debug_pathname", "modulename": "metacity.datamodel.datastore", "qualname": "debug_pathname", "type": "function", "doc": "<p></p>\n", "signature": "(pathname)", "funcdef": "def"}, {"fullname": "metacity.datamodel.datastore.DataStore", "modulename": "metacity.datamodel.datastore", "qualname": "DataStore", "type": "class", "doc": "<p></p>\n"}, {"fullname": "metacity.datamodel.datastore.DataStore.__init__", "modulename": "metacity.datamodel.datastore", "qualname": "DataStore.__init__", "type": "function", "doc": "<p>Initialize or open an existing data store. Data store contains individual layers,\nhandles storing data on the disk and loading. Internally, the data store is a \ndirectory and all layers are stored in subdirectories.</p>\n\n<p>The structure of the Data Store is as follows:</p>\n\n<pre><code>datastore_dir/\n\u2514\u2500\u2500\u2500layer_1/\n\u2502   \u2502\n\u2502   \u2502   BASE FILES\n\u2502   \u2502   ----------------------------------------------\n\u2502   \u2502   main.json   \u2502 all layer data in a single file\n\u2502   \u2502  \n\u2502   \u2502   PUBLISHED FILES\n\u2502   \u2502   ----------------------------------------------\n\u2502   \u2502   layout.json \u2502 structure of tiles for viewer\n\u2502   \u2502   x1_y1.json  \u2502 tile data\n\u2502   \u2502   x2_y2.json  \u2502 tile data\n\u2502   \u2502   ... \n\u2502   \n\u2514\u2500\u2500\u2500layer_2/\n\u2502   ...\n</code></pre>\n\n<h6 id=\"important-files\">Important files</h6>\n\n<blockquote>\n  <ul>\n  <li><code>main.json</code> contains all of the layer data, including object data, \n  geometry and metadata</li>\n  <li><code>layout.json</code> contains the structure of the tiles for the web \n  viewer - namely tile coordinates, sizes and filenames</li>\n  <li><code>x_y.json</code> contains the tile data for the tile at the specified \n  coordinates - namely the tile geometry and metadata of the objects\n  with centroids contained in the tile</li>\n  </ul>\n</blockquote>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>directory (str):</strong>  The directory of the data store.</li>\n</ul>\n\n<h6 id=\"example\">Example</h6>\n\n<blockquote>\n  <p>Create an empty data store.</p>\n</blockquote>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ds</span> <span class=\"o\">=</span> <span class=\"n\">DataStore</span><span class=\"p\">(</span><span class=\"s2\">&quot;store&quot;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">listdir</span><span class=\"p\">(</span><span class=\"n\">ds</span><span class=\"o\">.</span><span class=\"n\">directory</span><span class=\"p\">)</span>\n<span class=\"go\">[]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ds</span> <span class=\"o\">=</span> <span class=\"n\">DataStore</span><span class=\"p\">(</span><span class=\"s2\">&quot;*&quot;</span><span class=\"p\">)</span>\n<span class=\"go\">ValueError: * is not a valid pathname.</span>\n</code></pre></div>\n", "signature": "(self, directory)", "funcdef": "def"}, {"fullname": "metacity.datamodel.datastore.DataStore.list_layers", "modulename": "metacity.datamodel.datastore", "qualname": "DataStore.list_layers", "type": "function", "doc": "<p>List all layers in the data store.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>List[str]: The names of the layers.</p>\n</blockquote>\n\n<h6 id=\"example\">Example</h6>\n\n<blockquote>\n  <p>Create a data store and add a layer, list existing layers.</p>\n</blockquote>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ds</span> <span class=\"o\">=</span> <span class=\"n\">DataStore</span><span class=\"p\">(</span><span class=\"s2\">&quot;store&quot;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ds</span><span class=\"o\">.</span><span class=\"n\">add_layer</span><span class=\"p\">(</span><span class=\"n\">Layer</span><span class=\"p\">(</span><span class=\"s2\">&quot;terrain&quot;</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ds</span><span class=\"o\">.</span><span class=\"n\">list_layers</span><span class=\"p\">()</span>\n<span class=\"go\">[&quot;terrain&quot;]</span>\n</code></pre></div>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "metacity.datamodel.datastore.DataStore.get_layer", "modulename": "metacity.datamodel.datastore", "qualname": "DataStore.get_layer", "type": "function", "doc": "<p>Get a layer based on its name from the data store. If the layer does not exist, \nNone is returned.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>layer_name (str):</strong>  The name of the layer to get.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Layer: The layer.</p>\n</blockquote>\n", "signature": "(self, layer_name)", "funcdef": "def"}, {"fullname": "metacity.datamodel.datastore.DataStore.layers", "modulename": "metacity.datamodel.datastore", "qualname": "DataStore.layers", "type": "variable", "doc": "<p>Generator, yields Layer stored in the data store. </p>\n\n<h6 id=\"yields\">Yields</h6>\n\n<blockquote>\n  <p>Layer: each Layer in the data store.</p>\n</blockquote>\n\n<h6 id=\"example\">Example</h6>\n\n<blockquote>\n  <p>Generate a list of names of layers in the data store.</p>\n</blockquote>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ds</span> <span class=\"o\">=</span> <span class=\"n\">DataStore</span><span class=\"p\">(</span><span class=\"s2\">&quot;store&quot;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">for</span> <span class=\"n\">name</span> <span class=\"ow\">in</span> <span class=\"p\">[</span><span class=\"s2\">&quot;terrain&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;buildings&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;roads&quot;</span><span class=\"p\">]:</span>\n<span class=\"gp\">... </span>    <span class=\"n\">ds</span><span class=\"o\">.</span><span class=\"n\">add_layer</span><span class=\"p\">(</span><span class=\"n\">Layer</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">[</span><span class=\"n\">l</span><span class=\"o\">.</span><span class=\"n\">name</span> <span class=\"k\">for</span> <span class=\"n\">l</span> <span class=\"ow\">in</span> <span class=\"n\">ds</span><span class=\"o\">.</span><span class=\"n\">layers</span><span class=\"p\">]</span>\n<span class=\"go\">[&#39;terrain&#39;, &#39;buildings&#39;, &#39;roads&#39;]</span>\n</code></pre></div>\n"}, {"fullname": "metacity.datamodel.datastore.DataStore.add_layer", "modulename": "metacity.datamodel.datastore", "qualname": "DataStore.add_layer", "type": "function", "doc": "<p>Add a layer to the data store. Adding a layer to the datastore persists the \nlayer onto the disk. </p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>layer (Layer):</strong>  The layer to add.</li>\n</ul>\n\n<h6 id=\"example\">Example</h6>\n\n<blockquote>\n  <p>Add layer to existing datastore.</p>\n</blockquote>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ds</span> <span class=\"o\">=</span> <span class=\"n\">DataStore</span><span class=\"p\">(</span><span class=\"s2\">&quot;store&quot;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">[</span><span class=\"n\">l</span><span class=\"o\">.</span><span class=\"n\">name</span> <span class=\"k\">for</span> <span class=\"n\">l</span> <span class=\"ow\">in</span> <span class=\"n\">ds</span><span class=\"o\">.</span><span class=\"n\">layers</span><span class=\"p\">]</span>\n<span class=\"go\">[]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ds</span><span class=\"o\">.</span><span class=\"n\">add_layer</span><span class=\"p\">(</span><span class=\"n\">Layer</span><span class=\"p\">(</span><span class=\"s2\">&quot;terrain&quot;</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">[</span><span class=\"n\">l</span><span class=\"o\">.</span><span class=\"n\">name</span> <span class=\"k\">for</span> <span class=\"n\">l</span> <span class=\"ow\">in</span> <span class=\"n\">ds</span><span class=\"o\">.</span><span class=\"n\">layers</span><span class=\"p\">]</span>\n<span class=\"go\">[&#39;terrain&#39;]</span>\n</code></pre></div>\n", "signature": "(self, layer: metacity.datamodel.layer.Layer)", "funcdef": "def"}, {"fullname": "metacity.datamodel.datastore.DataStore.publish_layer", "modulename": "metacity.datamodel.datastore", "qualname": "DataStore.publish_layer", "type": "function", "doc": "<p>Publish a layer to the data store. Publishing stores all of the static \nfiles required by the web viewer.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>layer (Layer):</strong>  The layer to publish.</li>\n</ul>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<blockquote>\n  <p><code>DataStore</code> see constructor to check the layout of the\n  publish files.</p>\n</blockquote>\n", "signature": "(self, layer: metacity.datamodel.layer.Layer)", "funcdef": "def"}, {"fullname": "metacity.datamodel.datastore.DataStore.update_layer", "modulename": "metacity.datamodel.datastore", "qualname": "DataStore.update_layer", "type": "function", "doc": "<p>Update a layer in the data store.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>layer (Layer):</strong>  The layer to update.</li>\n</ul>\n", "signature": "(self, layer: metacity.datamodel.layer.Layer)", "funcdef": "def"}, {"fullname": "metacity.datamodel.datastore.DataStore.layer_dir", "modulename": "metacity.datamodel.datastore", "qualname": "DataStore.layer_dir", "type": "function", "doc": "<p>Get the directory of the layer in the Data Store.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>layer (Layer):</strong>  The layer to get the directory of.</li>\n</ul>\n", "signature": "(self, layer: metacity.datamodel.layer.Layer)", "funcdef": "def"}, {"fullname": "metacity.datamodel.datastore.DataStore.tile_file", "modulename": "metacity.datamodel.datastore", "qualname": "DataStore.tile_file", "type": "function", "doc": "<p>Get the file path of a tile in the data store.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>layer_dir (str):</strong>  The directory of the layer.</li>\n<li><strong>tile (Tuple[int, int]):</strong>  The tile to get the file path of.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>str: The file path of the tile.</p>\n</blockquote>\n", "signature": "(self, layer_dir: str, tile: metacity.datamodel.grid.Tile)", "funcdef": "def"}, {"fullname": "metacity.datamodel.grid", "modulename": "metacity.datamodel.grid", "type": "module", "doc": "<p></p>\n"}, {"fullname": "metacity.datamodel.grid.Tile", "modulename": "metacity.datamodel.grid", "qualname": "Tile", "type": "class", "doc": "<p></p>\n"}, {"fullname": "metacity.datamodel.grid.Tile.__init__", "modulename": "metacity.datamodel.grid", "qualname": "Tile.__init__", "type": "function", "doc": "<p>Initialize a tile. The tile spans a rectangular area with the dimensions specified.\nParameters x and y always define the origin coordinates and the width and height define \nthe area of the tile spanning from x to x + width, analogous for y-axis.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>x (float):</strong>  The base x coordinate of the tile.</li>\n<li><strong>y (float):</strong>  The base y coordinate of the tile.</li>\n<li><strong>width (float):</strong>  The width of the tile.</li>\n<li><strong>height (float):</strong>  The height of the tile.</li>\n</ul>\n\n<h6 id=\"example\">Example</h6>\n\n<blockquote>\n  <p>Initialize a tile with the origin coordinates (0, 0) and the dimensions of (100, 100):</p>\n</blockquote>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">tile</span> <span class=\"o\">=</span> <span class=\"n\">Tile</span><span class=\"p\">(</span><span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">100.0</span><span class=\"p\">,</span> <span class=\"mf\">100.0</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">tile</span><span class=\"o\">.</span><span class=\"n\">width</span>\n<span class=\"go\">100.0</span>\n</code></pre></div>\n", "signature": "(self, x: float, y: float, width: float, height: float)", "funcdef": "def"}, {"fullname": "metacity.datamodel.grid.Tile.add_object", "modulename": "metacity.datamodel.grid", "qualname": "Tile.add_object", "type": "function", "doc": "<p>Add an object to the tile. </p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>object (Object):</strong>  The object to add.</li>\n</ul>\n", "signature": "(self, object: metacity.datamodel.object.Object)", "funcdef": "def"}, {"fullname": "metacity.datamodel.grid.Tile.serialize", "modulename": "metacity.datamodel.grid", "qualname": "Tile.serialize", "type": "function", "doc": "<p>Serialize the tile. The serialized tile is a dictionary with the following keys:</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// The base x coordinate of the tile.</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"s2\">&quot;x&quot;</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kr\">float</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// The base y coordinate of the tile.</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"s2\">&quot;y&quot;</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kr\">float</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// The width of the tile.</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"s2\">&quot;width&quot;</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kr\">float</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// The height of the tile.</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"s2\">&quot;height&quot;</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kr\">float</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// The objects in the tile</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"s2\">&quot;objects&quot;</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"w\"> </span><span class=\"nb\">JSON</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">JSON</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">...</span><span class=\"w\"> </span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Dict: The serialized tile.</p>\n</blockquote>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<blockquote>\n  <p><code>metacity.datamodel.object.Object.serialize</code> for the serialization of an Object into JSON</p>\n</blockquote>\n\n<h6 id=\"example\">Example</h6>\n\n<blockquote>\n  <p>Serialize a tile:</p>\n</blockquote>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">tile</span> <span class=\"o\">=</span> <span class=\"n\">Tile</span><span class=\"p\">(</span><span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">1000.0</span><span class=\"p\">,</span> <span class=\"mf\">1000.0</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">object</span> <span class=\"o\">=</span> <span class=\"n\">metacity</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">&#39;single_point_object.shp&#39;</span><span class=\"p\">)[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">tile</span><span class=\"o\">.</span><span class=\"n\">add_object</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">tile</span><span class=\"o\">.</span><span class=\"n\">serialize</span><span class=\"p\">()</span>\n<span class=\"go\">{</span>\n<span class=\"go\">    &quot;x&quot;: 0.0,</span>\n<span class=\"go\">    &quot;y&quot;: 0.0,</span>\n<span class=\"go\">    &quot;width&quot;: 1000.0,</span>\n<span class=\"go\">    &quot;height&quot;: 1000.0,</span>\n<span class=\"go\">    &quot;objects&quot;: [JSON]</span>\n<span class=\"go\">}</span>\n</code></pre></div>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "metacity.datamodel.grid.Tile.deserialize", "modulename": "metacity.datamodel.grid", "qualname": "Tile.deserialize", "type": "function", "doc": "<p>Deserialize the tile, static method.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>data (Dict):</strong>  The data to deserialize.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Tile: The deserialized tile.</p>\n</blockquote>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<blockquote>\n  <p><code>Tile.serialize</code> for the serialization of a tile into a dictionary</p>\n</blockquote>\n\n<h6 id=\"example\">Example</h6>\n\n<blockquote>\n  <p>Deserialize a tile:</p>\n</blockquote>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">tile</span> <span class=\"o\">=</span> <span class=\"n\">Tile</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">tile</span><span class=\"o\">.</span><span class=\"n\">width</span>\n<span class=\"go\">100</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">tile</span> <span class=\"o\">=</span> <span class=\"n\">Tile</span><span class=\"o\">.</span><span class=\"n\">deserialize</span><span class=\"p\">({</span><span class=\"s2\">&quot;x&quot;</span><span class=\"p\">:</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"s2\">&quot;y&quot;</span><span class=\"p\">:</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"s2\">&quot;width&quot;</span><span class=\"p\">:</span> <span class=\"mf\">1000.0</span><span class=\"p\">,</span> <span class=\"s2\">&quot;height&quot;</span><span class=\"p\">:</span> <span class=\"mf\">1000.0</span><span class=\"p\">,</span> <span class=\"s2\">&quot;objects&quot;</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"n\">JSON</span><span class=\"p\">,</span> <span class=\"n\">JSON</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]})</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">tile</span><span class=\"o\">.</span><span class=\"n\">width</span>\n<span class=\"go\">1000</span>\n</code></pre></div>\n", "signature": "(data: Dict)", "funcdef": "def"}, {"fullname": "metacity.datamodel.grid.Grid", "modulename": "metacity.datamodel.grid", "qualname": "Grid", "type": "class", "doc": "<p></p>\n"}, {"fullname": "metacity.datamodel.grid.Grid.__init__", "modulename": "metacity.datamodel.grid", "qualname": "Grid.__init__", "type": "function", "doc": "<p>Initialize a regular grid. All tiles are rectangles, aligned to axis with fixed dimensions.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>tile_xdim (float):</strong>  The x dimension of a single tile. Default is 1000.0.</li>\n<li><strong>tile_ydim (float):</strong>  The y dimension of a single tile. Default is 1000.0.</li>\n</ul>\n\n<h6 id=\"example\">Example</h6>\n\n<blockquote>\n  <p>Initialize an empty grid with tile dimensions of 1000.0:</p>\n</blockquote>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">grid</span> <span class=\"o\">=</span> <span class=\"n\">Grid</span><span class=\"p\">(</span><span class=\"mf\">1000.0</span><span class=\"p\">,</span> <span class=\"mf\">1000.0</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">grid</span><span class=\"o\">.</span><span class=\"n\">tile_xdim</span>\n<span class=\"go\">1000.0</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">grid</span><span class=\"o\">.</span><span class=\"n\">tiles</span>\n<span class=\"go\">{}</span>\n</code></pre></div>\n", "signature": "(self, tile_xdim: float = 1000.0, tile_ydim: float = 1000.0)", "funcdef": "def"}, {"fullname": "metacity.datamodel.grid.Grid.add_object", "modulename": "metacity.datamodel.grid", "qualname": "Grid.add_object", "type": "function", "doc": "<p>Add an object to the grid. The object will be added to the tile it is contained in.\nIf object has multiple geometries, take average of all geometry centroids and \nuse it as the tile selection pivot.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>object (Object):</strong>  The object to add.</li>\n</ul>\n\n<h6 id=\"example\">Example</h6>\n\n<blockquote>\n  <p>Add an object to the grid:</p>\n</blockquote>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">grid</span> <span class=\"o\">=</span> <span class=\"n\">Grid</span><span class=\"p\">(</span><span class=\"mf\">1000.0</span><span class=\"p\">,</span> <span class=\"mf\">1000.0</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">object</span> <span class=\"o\">=</span> <span class=\"n\">metacity</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">&#39;single_point_object.shp&#39;</span><span class=\"p\">)[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">grid</span><span class=\"o\">.</span><span class=\"n\">tiles</span>\n<span class=\"go\">{}</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">grid</span><span class=\"o\">.</span><span class=\"n\">add_object</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">grid</span><span class=\"o\">.</span><span class=\"n\">tiles</span>\n<span class=\"go\">{(0, 0): Tile(0, 0, 1000.0, 1000.0)}</span>\n</code></pre></div>\n", "signature": "(self, object: metacity.datamodel.object.Object)", "funcdef": "def"}, {"fullname": "metacity.datamodel.grid.Grid.get_tile", "modulename": "metacity.datamodel.grid", "qualname": "Grid.get_tile", "type": "function", "doc": "<p>Get the tile at the given coordinates. If the tile does not exist, it will be created.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>x (float):</strong>  The x coordinate of the pivot to get the tile for.</li>\n<li><strong>y (float):</strong>  The y coordinate of the pivot to get the tile for.</li>\n</ul>\n\n<h6 id=\"example\">Example</h6>\n\n<blockquote>\n  <p>Get a tile at the given coordinates:</p>\n</blockquote>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">grid</span> <span class=\"o\">=</span> <span class=\"n\">Grid</span><span class=\"p\">(</span><span class=\"mf\">1000.0</span><span class=\"p\">,</span> <span class=\"mf\">1000.0</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">grid</span><span class=\"o\">.</span><span class=\"n\">tiles</span>\n<span class=\"go\">{}</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">grid</span><span class=\"o\">.</span><span class=\"n\">get_tile</span><span class=\"p\">(</span><span class=\"mi\">15000</span><span class=\"p\">,</span> <span class=\"mi\">15000</span><span class=\"p\">)</span>\n<span class=\"go\">Tile(15000, 15000, 1000.0, 1000.0)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">grid</span><span class=\"o\">.</span><span class=\"n\">add_object</span><span class=\"p\">(</span><span class=\"n\">metacity</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">&#39;single_point_object.shp&#39;</span><span class=\"p\">)[</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">grid</span><span class=\"o\">.</span><span class=\"n\">tiles</span>\n<span class=\"go\">{(0, 0): Tile(0, 0, 1000.0, 1000.0), (15000, 15000): Tile(15000, 15000, 1000.0, 1000.0)}</span>\n</code></pre></div>\n", "signature": "(self, x: float, y: float)", "funcdef": "def"}, {"fullname": "metacity.datamodel.grid.Grid.serialize", "modulename": "metacity.datamodel.grid", "qualname": "Grid.serialize", "type": "function", "doc": "<p>Serialize the grid. The tiles are serialized separately.\nThe structure of returned data follows:</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">//serialized tiles</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"s2\">&quot;tiles&quot;</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"w\"> </span><span class=\"nb\">JSON</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">JSON</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">...</span><span class=\"w\"> </span><span class=\"p\">],</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">//dimension of a single tile in x-axis,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"s2\">&quot;tile_xdim&quot;</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kr\">float</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">//dimension of a single tile in y-axis</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"s2\">&quot;tile_ydim&quot;</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kr\">float</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Dict: The serialized grid.</p>\n</blockquote>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<blockquote>\n  <p><code>Tile.serialize</code> for the structure of a tile JSON.</p>\n</blockquote>\n\n<h6 id=\"example\">Example</h6>\n\n<blockquote>\n  <p>Serialize a grid:</p>\n</blockquote>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">grid</span> <span class=\"o\">=</span> <span class=\"n\">Grid</span><span class=\"p\">(</span><span class=\"mf\">1000.0</span><span class=\"p\">,</span> <span class=\"mf\">1000.0</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">grid</span><span class=\"o\">.</span><span class=\"n\">get_tile</span><span class=\"p\">(</span><span class=\"mi\">15000</span><span class=\"p\">,</span> <span class=\"mi\">15000</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">grid</span><span class=\"o\">.</span><span class=\"n\">serialize</span><span class=\"p\">()</span>\n<span class=\"go\">{</span>\n<span class=\"go\">    &quot;tiles&quot;: [</span>\n<span class=\"go\">        {</span>\n<span class=\"go\">            &quot;x&quot;: 15000,</span>\n<span class=\"go\">            &quot;y&quot;: 1500,</span>\n<span class=\"go\">            &quot;width&quot;: 1000.0,</span>\n<span class=\"go\">            &quot;height&quot;: 1000.0,</span>\n<span class=\"go\">            &quot;objects&quot;: []</span>\n<span class=\"go\">        }</span>\n<span class=\"go\">    ],</span>\n<span class=\"go\">    &quot;tile_xdim&quot;: 1000.0,</span>\n<span class=\"go\">    &quot;tile_ydim&quot;: 1000.0</span>\n<span class=\"go\">}</span>\n</code></pre></div>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "metacity.datamodel.grid.Grid.deserialize", "modulename": "metacity.datamodel.grid", "qualname": "Grid.deserialize", "type": "function", "doc": "<p>Deserialize the grid, static method The tiles are deserialized separately.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>data (Dict):</strong>  The data to deserialize.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Grid: The deserialized grid.</p>\n</blockquote>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<blockquote>\n  <p><code>Grid.serialize</code> see for the structure of the data.</p>\n</blockquote>\n\n<h6 id=\"example\">Example</h6>\n\n<blockquote>\n  <p>Deserialize a grid:</p>\n</blockquote>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">grid</span> <span class=\"o\">=</span> <span class=\"n\">Grid</span><span class=\"p\">(</span><span class=\"mf\">1000.0</span><span class=\"p\">,</span> <span class=\"mf\">1000.0</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">grid</span><span class=\"o\">.</span><span class=\"n\">get_tile</span><span class=\"p\">(</span><span class=\"mi\">15000</span><span class=\"p\">,</span> <span class=\"mi\">15000</span><span class=\"p\">)</span>\n<span class=\"go\">Tile(15000, 15000, 1000.0, 1000.0)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">grid</span><span class=\"o\">.</span><span class=\"n\">add_object</span><span class=\"p\">(</span><span class=\"n\">metacity</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">&#39;single_point_object.shp&#39;</span><span class=\"p\">)[</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">grid</span><span class=\"o\">.</span><span class=\"n\">serialize</span><span class=\"p\">()</span>\n<span class=\"go\">{</span>\n<span class=\"go\">    &quot;tiles&quot;: [</span>\n<span class=\"go\">        {</span>\n<span class=\"go\">            &quot;x&quot;: 15000,</span>\n<span class=\"go\">            &quot;y&quot;: 15000,</span>\n<span class=\"go\">            &quot;width&quot;: 1000.0,</span>\n<span class=\"go\">            &quot;height&quot;: 1000.0,</span>\n<span class=\"go\">            &quot;objects&quot;: []</span>\n<span class=\"go\">        },</span>\n<span class=\"go\">        {</span>\n<span class=\"go\">            &quot;x&quot;: 0,</span>\n<span class=\"go\">            &quot;y&quot;: 0,</span>\n<span class=\"go\">            &quot;width&quot;: 1000.0,</span>\n<span class=\"go\">            &quot;height&quot;: 1000.0,</span>\n<span class=\"go\">            &quot;objects&quot;: [JSON]</span>\n<span class=\"go\">        }</span>\n<span class=\"go\">    ],</span>\n<span class=\"go\">    &quot;tile_xdim&quot;: 1000.0,</span>\n<span class=\"go\">    &quot;tile_ydim&quot;: 1000.0</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">grid_deserialized</span> <span class=\"o\">=</span> <span class=\"n\">Grid</span><span class=\"o\">.</span><span class=\"n\">deserialize</span><span class=\"p\">(</span><span class=\"n\">grid</span><span class=\"o\">.</span><span class=\"n\">serialize</span><span class=\"p\">())</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">grid_deserialized</span><span class=\"o\">.</span><span class=\"n\">tiles</span>\n<span class=\"go\">{(0, 0): Tile(0, 0, 1000.0, 1000.0), (15000, 15000): Tile(15000, 15000, 1000.0, 1000.0)}</span>\n</code></pre></div>\n", "signature": "(data: Dict)", "funcdef": "def"}, {"fullname": "metacity.datamodel.grid.Grid.objects", "modulename": "metacity.datamodel.grid", "qualname": "Grid.objects", "type": "variable", "doc": "<p>Iterate over all objects in the grid.</p>\n\n<h6 id=\"yields\">Yields</h6>\n\n<blockquote>\n  <p>Object: The objects in the grid.</p>\n</blockquote>\n\n<p>Example:</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">grid</span> <span class=\"o\">=</span> <span class=\"n\">Grid</span><span class=\"p\">(</span><span class=\"mf\">1000.0</span><span class=\"p\">,</span> <span class=\"mf\">1000.0</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">grid</span><span class=\"o\">.</span><span class=\"n\">add_object</span><span class=\"p\">(</span><span class=\"n\">metacity</span><span class=\"o\">.</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">&#39;single_point_object.shp&#39;</span><span class=\"p\">)[</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">grid</span><span class=\"o\">.</span><span class=\"n\">objects</span>\n<span class=\"go\">[Object(single_point_object.shp)]</span>\n</code></pre></div>\n"}, {"fullname": "metacity.datamodel.layer", "modulename": "metacity.datamodel.layer", "type": "module", "doc": "<p></p>\n"}, {"fullname": "metacity.datamodel.layer.Layer", "modulename": "metacity.datamodel.layer", "qualname": "Layer", "type": "class", "doc": "<p></p>\n"}, {"fullname": "metacity.datamodel.layer.Layer.__init__", "modulename": "metacity.datamodel.layer", "qualname": "Layer.__init__", "type": "function", "doc": "<p>Initialize a layer. Layer represents a collection of objects.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>name (str):</strong>  The name of the layer.</li>\n<li><strong>tile_xdim (float):</strong>  The x dimension of the tiles. Default is 1000.0.</li>\n<li><strong>tile_ydim (float):</strong>  The y dimension of the tiles. Default is 1000.0.</li>\n</ul>\n", "signature": "(\n    self,\n    name: str,\n    tile_xdim: float = 1000.0,\n    tile_ydim: float = 1000.0\n)", "funcdef": "def"}, {"fullname": "metacity.datamodel.layer.Layer.add_object", "modulename": "metacity.datamodel.layer", "qualname": "Layer.add_object", "type": "function", "doc": "<p>Add an object to the layer.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>obj (Object):</strong>  The object to add.</li>\n</ul>\n", "signature": "(self, obj: metacity.datamodel.object.Object)", "funcdef": "def"}, {"fullname": "metacity.datamodel.layer.Layer.add_objects", "modulename": "metacity.datamodel.layer", "qualname": "Layer.add_objects", "type": "function", "doc": "<p>Add objects to the layer. </p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>objs (List[Object]):</strong>  The objects to add.</li>\n</ul>\n", "signature": "(self, objs: List[metacity.datamodel.object.Object])", "funcdef": "def"}, {"fullname": "metacity.datamodel.layer.Layer.serialize", "modulename": "metacity.datamodel.layer", "qualname": "Layer.serialize", "type": "function", "doc": "<p>Serialize the layer. The serialized layer is a dictionary with the following keys:</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// The name of the layer.</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"s2\">&quot;name&quot;</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"nx\">str</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// The grid of the layer.</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"s2\">&quot;grid&quot;</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"nb\">JSON</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Dict: The serialized layer.</p>\n</blockquote>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<blockquote>\n  <p><code>metacity.datamodel.grid.Grid.serialize</code> for the serialization of a grid into JSON</p>\n</blockquote>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "metacity.datamodel.layer.Layer.deserialize", "modulename": "metacity.datamodel.layer", "qualname": "Layer.deserialize", "type": "function", "doc": "<p>Deserialize the layer, static method.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>data (Dict):</strong>  The data to deserialize.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Layer: The deserialized layer.</p>\n</blockquote>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<blockquote>\n  <p><code>Layer.serialize</code> for the serialization of a layer into a dictionary</p>\n</blockquote>\n", "signature": "(data: Dict)", "funcdef": "def"}, {"fullname": "metacity.datamodel.layer.Layer.objects", "modulename": "metacity.datamodel.layer", "qualname": "Layer.objects", "type": "variable", "doc": "<p>Generator, yields objects in the layer.</p>\n\n<h6 id=\"yields\">Yields</h6>\n\n<blockquote>\n  <p>Object: The objects in the layer.</p>\n</blockquote>\n"}, {"fullname": "metacity.datamodel.object", "modulename": "metacity.datamodel.object", "type": "module", "doc": "<p></p>\n"}, {"fullname": "metacity.datamodel.object.types", "modulename": "metacity.datamodel.object", "qualname": "types", "type": "variable", "doc": "<p>The types used to deserialize geometry objects.</p>\n", "annotation": ": Dict[str, Callable[[], metacity.geometry.Model]]", "default_value": " = {'points': <class 'metacity.geometry.Points'>, 'segments': <class 'metacity.geometry.Segments'>, 'mesh': <class 'metacity.geometry.Mesh'>}"}, {"fullname": "metacity.datamodel.object.desermodel", "modulename": "metacity.datamodel.object", "qualname": "desermodel", "type": "function", "doc": "<p>Deserialize a geometry object, raising an exception if the type is not supported.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>geometry (Dict):</strong>  The geometry object to deserialize.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Model: The deserialized geometry object.</p>\n</blockquote>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError:</strong>  If the type is not supported.</li>\n</ul>\n", "signature": "(geometry: metacity.geometry.Model)", "funcdef": "def"}, {"fullname": "metacity.datamodel.object.Object", "modulename": "metacity.datamodel.object", "qualname": "Object", "type": "class", "doc": "<p></p>\n"}, {"fullname": "metacity.datamodel.object.Object.__init__", "modulename": "metacity.datamodel.object", "qualname": "Object.__init__", "type": "function", "doc": "<p>Initialize an empty object. Each objects represents a collection of geometries and metadata.\nSingle object can have multiple instances of geometry and a single dictionary of key-value pairs.\nAll values in the metadata dictionary need to be serializable.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "metacity.datamodel.object.Object.serialize", "modulename": "metacity.datamodel.object", "qualname": "Object.serialize", "type": "function", "doc": "<p>Serialize the object. The serialization is a dictionary with the following keys:</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// The metadata of the object.</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"s2\">&quot;meta&quot;</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"s2\">&quot;key&quot;</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">&quot;value&quot;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">...</span><span class=\"w\"> </span><span class=\"p\">},</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// The geometries of the object.</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"s2\">&quot;geometry&quot;</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"w\"> </span><span class=\"nb\">JSON</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">JSON</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">...</span><span class=\"w\"> </span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<blockquote>\n  <p><code>metacity.geometry.Model.serialize</code> for the serialization of a geometry into JSON</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Dict: The serialized object.</p>\n</blockquote>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "metacity.datamodel.object.Object.deserialize", "modulename": "metacity.datamodel.object", "qualname": "Object.deserialize", "type": "function", "doc": "<p>Deserialize the object, a static method.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>data (Dict):</strong>  The data to deserialize.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Object: The deserialized object.</p>\n</blockquote>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<blockquote>\n  <p><code>Object.serialize</code> for the serialization of an object into JSON</p>\n</blockquote>\n", "signature": "(data: Dict)", "funcdef": "def"}, {"fullname": "metacity.geometry", "modulename": "metacity.geometry", "type": "module", "doc": "<p></p>\n"}, {"fullname": "metacity.geometry.BaseModel", "modulename": "metacity.geometry", "qualname": "BaseModel", "type": "class", "doc": "<p>Doc test base model</p>\n", "bases": "pybind11_builtins.pybind11_object"}, {"fullname": "metacity.geometry.BaseModel.__init__", "modulename": "metacity.geometry", "qualname": "BaseModel.__init__", "type": "function", "doc": "<p>__init__(self: metacity.geometry.BaseModel) -> None</p>\n\n<p>Base model constructor</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.BaseModel.type", "modulename": "metacity.geometry", "qualname": "BaseModel.type", "type": "variable", "doc": "<p>(arg0: metacity.geometry.BaseModel) -> str</p>\n"}, {"fullname": "metacity.geometry.BaseModel.tags", "modulename": "metacity.geometry", "qualname": "BaseModel.tags", "type": "variable", "doc": "<p>(arg0: metacity.geometry.BaseModel) -> json</p>\n"}, {"fullname": "metacity.geometry.BaseModel.add_tag", "modulename": "metacity.geometry", "qualname": "BaseModel.add_tag", "type": "function", "doc": "<p>add_tag(self: metacity.geometry.BaseModel, arg0: str, arg1: int) -> None</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.ModelLoader", "modulename": "metacity.geometry", "qualname": "ModelLoader", "type": "class", "doc": "<p></p>\n", "bases": "pybind11_builtins.pybind11_object"}, {"fullname": "metacity.geometry.ModelLoader.__init__", "modulename": "metacity.geometry", "qualname": "ModelLoader.__init__", "type": "function", "doc": "<p>__init__(self: metacity.geometry.ModelLoader) -> None</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.ModelLoader.type", "modulename": "metacity.geometry", "qualname": "ModelLoader.type", "type": "variable", "doc": "<p>(arg0: metacity.geometry.ModelLoader) -> str</p>\n"}, {"fullname": "metacity.geometry.ModelLoader.transform", "modulename": "metacity.geometry", "qualname": "ModelLoader.transform", "type": "function", "doc": "<p>transform(self: metacity.geometry.ModelLoader) -> Model</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.MultiPoint", "modulename": "metacity.geometry", "qualname": "MultiPoint", "type": "class", "doc": "<p>Doc test base model</p>\n", "bases": "BaseModel"}, {"fullname": "metacity.geometry.MultiPoint.__init__", "modulename": "metacity.geometry", "qualname": "MultiPoint.__init__", "type": "function", "doc": "<p>__init__(self: metacity.geometry.MultiPoint) -> None</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.MultiPoint.type", "modulename": "metacity.geometry", "qualname": "MultiPoint.type", "type": "variable", "doc": "<p>(arg0: metacity.geometry.MultiPoint) -> str</p>\n"}, {"fullname": "metacity.geometry.MultiPoint.push_p2", "modulename": "metacity.geometry", "qualname": "MultiPoint.push_p2", "type": "function", "doc": "<p>push_p2(self: metacity.geometry.MultiPoint, arg0: List[float]) -> None</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.MultiPoint.push_p3", "modulename": "metacity.geometry", "qualname": "MultiPoint.push_p3", "type": "function", "doc": "<p>push_p3(self: metacity.geometry.MultiPoint, arg0: List[float]) -> None</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.MultiPoint.transform", "modulename": "metacity.geometry", "qualname": "MultiPoint.transform", "type": "function", "doc": "<p>transform(self: metacity.geometry.MultiPoint) -> Model</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.MultiLine", "modulename": "metacity.geometry", "qualname": "MultiLine", "type": "class", "doc": "<p>Doc test base model</p>\n", "bases": "BaseModel"}, {"fullname": "metacity.geometry.MultiLine.__init__", "modulename": "metacity.geometry", "qualname": "MultiLine.__init__", "type": "function", "doc": "<p>__init__(self: metacity.geometry.MultiLine) -> None</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.MultiLine.type", "modulename": "metacity.geometry", "qualname": "MultiLine.type", "type": "variable", "doc": "<p>(arg0: metacity.geometry.MultiLine) -> str</p>\n"}, {"fullname": "metacity.geometry.MultiLine.push_l2", "modulename": "metacity.geometry", "qualname": "MultiLine.push_l2", "type": "function", "doc": "<p>push_l2(self: metacity.geometry.MultiLine, arg0: List[float]) -> None</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.MultiLine.push_l3", "modulename": "metacity.geometry", "qualname": "MultiLine.push_l3", "type": "function", "doc": "<p>push_l3(self: metacity.geometry.MultiLine, arg0: List[float]) -> None</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.MultiLine.transform", "modulename": "metacity.geometry", "qualname": "MultiLine.transform", "type": "function", "doc": "<p>transform(self: metacity.geometry.MultiLine) -> Model</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.MultiPolygon", "modulename": "metacity.geometry", "qualname": "MultiPolygon", "type": "class", "doc": "<p>Doc test base model</p>\n", "bases": "BaseModel"}, {"fullname": "metacity.geometry.MultiPolygon.__init__", "modulename": "metacity.geometry", "qualname": "MultiPolygon.__init__", "type": "function", "doc": "<p>__init__(self: metacity.geometry.MultiPolygon) -> None</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.MultiPolygon.type", "modulename": "metacity.geometry", "qualname": "MultiPolygon.type", "type": "variable", "doc": "<p>(arg0: metacity.geometry.MultiPolygon) -> str</p>\n"}, {"fullname": "metacity.geometry.MultiPolygon.push_p2", "modulename": "metacity.geometry", "qualname": "MultiPolygon.push_p2", "type": "function", "doc": "<p>push_p2(self: metacity.geometry.MultiPolygon, arg0: List[List[float]]) -> None</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.MultiPolygon.push_p3", "modulename": "metacity.geometry", "qualname": "MultiPolygon.push_p3", "type": "function", "doc": "<p>push_p3(self: metacity.geometry.MultiPolygon, arg0: List[List[float]]) -> None</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.MultiPolygon.transform", "modulename": "metacity.geometry", "qualname": "MultiPolygon.transform", "type": "function", "doc": "<p>transform(self: metacity.geometry.MultiPolygon) -> Model</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.Model", "modulename": "metacity.geometry", "qualname": "Model", "type": "class", "doc": "<p>Doc test base model</p>\n", "bases": "BaseModel"}, {"fullname": "metacity.geometry.Model.__init__", "modulename": "metacity.geometry", "qualname": "Model.__init__", "type": "function", "doc": "<p>__init__(self: metacity.geometry.Model) -> None</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.Model.type", "modulename": "metacity.geometry", "qualname": "Model.type", "type": "variable", "doc": "<p>(arg0: metacity.geometry.Model) -> str</p>\n"}, {"fullname": "metacity.geometry.Model.centroid", "modulename": "metacity.geometry", "qualname": "Model.centroid", "type": "variable", "doc": "<p>(arg0: metacity.geometry.Model) -> Tuple[float, float, float]</p>\n"}, {"fullname": "metacity.geometry.Model.bounding_box", "modulename": "metacity.geometry", "qualname": "Model.bounding_box", "type": "variable", "doc": "<p>(arg0: metacity.geometry.Model) -> Tuple[Tuple[float, float, float], Tuple[float, float, float]]</p>\n"}, {"fullname": "metacity.geometry.Model.shift", "modulename": "metacity.geometry", "qualname": "Model.shift", "type": "function", "doc": "<p>shift(self: metacity.geometry.Model, arg0: float, arg1: float, arg2: float) -> None</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.Model.add_attribute", "modulename": "metacity.geometry", "qualname": "Model.add_attribute", "type": "function", "doc": "<p>add_attribute(self: metacity.geometry.Model, arg0: str, arg1: int) -> None</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.Model.copy", "modulename": "metacity.geometry", "qualname": "Model.copy", "type": "function", "doc": "<p>copy(self: metacity.geometry.Model) -> metacity.geometry.Model</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.Model.to_obj", "modulename": "metacity.geometry", "qualname": "Model.to_obj", "type": "function", "doc": "<p>to_obj(self: metacity.geometry.Model, arg0: str, arg1: int) -> int</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.Model.serialize", "modulename": "metacity.geometry", "qualname": "Model.serialize", "type": "function", "doc": "<p>serialize(self: metacity.geometry.Model) -> json</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.Model.deserialize", "modulename": "metacity.geometry", "qualname": "Model.deserialize", "type": "function", "doc": "<p>deserialize(self: metacity.geometry.Model, arg0: json) -> None</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.Points", "modulename": "metacity.geometry", "qualname": "Points", "type": "class", "doc": "<p>Doc test base model</p>\n", "bases": "Model"}, {"fullname": "metacity.geometry.Points.__init__", "modulename": "metacity.geometry", "qualname": "Points.__init__", "type": "function", "doc": "<p>__init__(self: metacity.geometry.Points) -> None</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.Points.type", "modulename": "metacity.geometry", "qualname": "Points.type", "type": "variable", "doc": "<p>(arg0: metacity.geometry.Points) -> str</p>\n"}, {"fullname": "metacity.geometry.Points.copy", "modulename": "metacity.geometry", "qualname": "Points.copy", "type": "function", "doc": "<p>copy(self: metacity.geometry.Points) -> metacity.geometry.Model</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.Points.to_obj", "modulename": "metacity.geometry", "qualname": "Points.to_obj", "type": "function", "doc": "<p>to_obj(self: metacity.geometry.Points, arg0: str, arg1: int) -> int</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.Segments", "modulename": "metacity.geometry", "qualname": "Segments", "type": "class", "doc": "<p>Doc test base model</p>\n", "bases": "Model"}, {"fullname": "metacity.geometry.Segments.__init__", "modulename": "metacity.geometry", "qualname": "Segments.__init__", "type": "function", "doc": "<p>__init__(self: metacity.geometry.Segments) -> None</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.Segments.type", "modulename": "metacity.geometry", "qualname": "Segments.type", "type": "variable", "doc": "<p>(arg0: metacity.geometry.Segments) -> str</p>\n"}, {"fullname": "metacity.geometry.Segments.add_attribute", "modulename": "metacity.geometry", "qualname": "Segments.add_attribute", "type": "function", "doc": "<p>add_attribute(self: metacity.geometry.Segments, arg0: str, arg1: int) -> None</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.Segments.copy", "modulename": "metacity.geometry", "qualname": "Segments.copy", "type": "function", "doc": "<p>copy(self: metacity.geometry.Segments) -> metacity.geometry.Model</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.Segments.to_obj", "modulename": "metacity.geometry", "qualname": "Segments.to_obj", "type": "function", "doc": "<p>to_obj(self: metacity.geometry.Segments, arg0: str, arg1: int) -> int</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.Mesh", "modulename": "metacity.geometry", "qualname": "Mesh", "type": "class", "doc": "<p>Doc test base model</p>\n", "bases": "Model"}, {"fullname": "metacity.geometry.Mesh.__init__", "modulename": "metacity.geometry", "qualname": "Mesh.__init__", "type": "function", "doc": "<p>__init__(self: metacity.geometry.Mesh) -> None</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.Mesh.type", "modulename": "metacity.geometry", "qualname": "Mesh.type", "type": "variable", "doc": "<p>(arg0: metacity.geometry.Mesh) -> str</p>\n"}, {"fullname": "metacity.geometry.Mesh.copy", "modulename": "metacity.geometry", "qualname": "Mesh.copy", "type": "function", "doc": "<p>copy(self: metacity.geometry.Mesh) -> metacity.geometry.Model</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.Mesh.to_obj", "modulename": "metacity.geometry", "qualname": "Mesh.to_obj", "type": "function", "doc": "<p>to_obj(self: metacity.geometry.Mesh, arg0: str, arg1: int) -> int</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.LegoBuilder", "modulename": "metacity.geometry", "qualname": "LegoBuilder", "type": "class", "doc": "<p></p>\n", "bases": "pybind11_builtins.pybind11_object"}, {"fullname": "metacity.geometry.LegoBuilder.__init__", "modulename": "metacity.geometry", "qualname": "LegoBuilder.__init__", "type": "function", "doc": "<p>__init__(self: metacity.geometry.LegoBuilder) -> None</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.LegoBuilder.insert_model", "modulename": "metacity.geometry", "qualname": "LegoBuilder.insert_model", "type": "function", "doc": "<p>insert_model(self: metacity.geometry.LegoBuilder, arg0: metacity.geometry.Mesh) -> None</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.LegoBuilder.build_heightmap", "modulename": "metacity.geometry", "qualname": "LegoBuilder.build_heightmap", "type": "function", "doc": "<p>build_heightmap(self: metacity.geometry.LegoBuilder, arg0: float, arg1: float, arg2: float, arg3: float, arg4: int) -> None</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.LegoBuilder.legofy", "modulename": "metacity.geometry", "qualname": "LegoBuilder.legofy", "type": "function", "doc": "<p>legofy(self: metacity.geometry.LegoBuilder, arg0: int) -> json</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.geometry.LegoBuilder.lego_to_png", "modulename": "metacity.geometry", "qualname": "LegoBuilder.lego_to_png", "type": "function", "doc": "<p>lego_to_png(self: metacity.geometry.LegoBuilder, arg0: str) -> None</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "metacity.io", "modulename": "metacity.io", "type": "module", "doc": "<p></p>\n"}, {"fullname": "metacity.io.geojson", "modulename": "metacity.io.geojson", "type": "module", "doc": "<p></p>\n"}, {"fullname": "metacity.io.geojson.parser", "modulename": "metacity.io.geojson.parser", "type": "module", "doc": "<p></p>\n"}, {"fullname": "metacity.io.geojson.parser.flatten", "modulename": "metacity.io.geojson.parser", "qualname": "flatten", "type": "function", "doc": "<p></p>\n", "signature": "(data)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.flatten_polygon", "modulename": "metacity.io.geojson.parser", "qualname": "flatten_polygon", "type": "function", "doc": "<p></p>\n", "signature": "(polygon)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.GJGeometryObject", "modulename": "metacity.io.geojson.parser", "qualname": "GJGeometryObject", "type": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "abc.ABC"}, {"fullname": "metacity.io.geojson.parser.GJGeometryObject.set_coordinates", "modulename": "metacity.io.geojson.parser", "qualname": "GJGeometryObject.set_coordinates", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.GJGeometryObject.to_geometry", "modulename": "metacity.io.geojson.parser", "qualname": "GJGeometryObject.to_geometry", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.GJGeometryObject.dim", "modulename": "metacity.io.geojson.parser", "qualname": "GJGeometryObject.dim", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "metacity.io.geojson.parser.GJPoint", "modulename": "metacity.io.geojson.parser", "qualname": "GJPoint", "type": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "GJGeometryObject"}, {"fullname": "metacity.io.geojson.parser.GJPoint.__init__", "modulename": "metacity.io.geojson.parser", "qualname": "GJPoint.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.GJPoint.parse", "modulename": "metacity.io.geojson.parser", "qualname": "GJPoint.parse", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.GJPoint.to_geometry", "modulename": "metacity.io.geojson.parser", "qualname": "GJPoint.to_geometry", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.GJMultiPoint", "modulename": "metacity.io.geojson.parser", "qualname": "GJMultiPoint", "type": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "GJPoint"}, {"fullname": "metacity.io.geojson.parser.GJMultiPoint.__init__", "modulename": "metacity.io.geojson.parser", "qualname": "GJMultiPoint.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.GJMultiPoint.to_geometry", "modulename": "metacity.io.geojson.parser", "qualname": "GJMultiPoint.to_geometry", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.GJLine", "modulename": "metacity.io.geojson.parser", "qualname": "GJLine", "type": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "GJGeometryObject"}, {"fullname": "metacity.io.geojson.parser.GJLine.__init__", "modulename": "metacity.io.geojson.parser", "qualname": "GJLine.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.GJLine.parse", "modulename": "metacity.io.geojson.parser", "qualname": "GJLine.parse", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.GJLine.to_geometry", "modulename": "metacity.io.geojson.parser", "qualname": "GJLine.to_geometry", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.GJMultiLine", "modulename": "metacity.io.geojson.parser", "qualname": "GJMultiLine", "type": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "GJLine"}, {"fullname": "metacity.io.geojson.parser.GJMultiLine.__init__", "modulename": "metacity.io.geojson.parser", "qualname": "GJMultiLine.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.GJMultiLine.to_geometry", "modulename": "metacity.io.geojson.parser", "qualname": "GJMultiLine.to_geometry", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.GJPolygon", "modulename": "metacity.io.geojson.parser", "qualname": "GJPolygon", "type": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "GJGeometryObject"}, {"fullname": "metacity.io.geojson.parser.GJPolygon.__init__", "modulename": "metacity.io.geojson.parser", "qualname": "GJPolygon.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.GJPolygon.parse", "modulename": "metacity.io.geojson.parser", "qualname": "GJPolygon.parse", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.GJPolygon.to_geometry", "modulename": "metacity.io.geojson.parser", "qualname": "GJPolygon.to_geometry", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.GJMultiPolygon", "modulename": "metacity.io.geojson.parser", "qualname": "GJMultiPolygon", "type": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "GJPolygon"}, {"fullname": "metacity.io.geojson.parser.GJMultiPolygon.__init__", "modulename": "metacity.io.geojson.parser", "qualname": "GJMultiPolygon.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.GJMultiPolygon.to_geometry", "modulename": "metacity.io.geojson.parser", "qualname": "GJMultiPolygon.to_geometry", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.GJGeometryCollection", "modulename": "metacity.io.geojson.parser", "qualname": "GJGeometryCollection", "type": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "GJGeometryObject"}, {"fullname": "metacity.io.geojson.parser.GJGeometryCollection.__init__", "modulename": "metacity.io.geojson.parser", "qualname": "GJGeometryCollection.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.GJGeometryCollection.to_geometry", "modulename": "metacity.io.geojson.parser", "qualname": "GJGeometryCollection.to_geometry", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.GJFeature", "modulename": "metacity.io.geojson.parser", "qualname": "GJFeature", "type": "class", "doc": "<p></p>\n"}, {"fullname": "metacity.io.geojson.parser.GJFeature.__init__", "modulename": "metacity.io.geojson.parser", "qualname": "GJFeature.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.GJFeature.to_object", "modulename": "metacity.io.geojson.parser", "qualname": "GJFeature.to_object", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.GJFeatureCollection", "modulename": "metacity.io.geojson.parser", "qualname": "GJFeatureCollection", "type": "class", "doc": "<p></p>\n"}, {"fullname": "metacity.io.geojson.parser.GJFeatureCollection.__init__", "modulename": "metacity.io.geojson.parser", "qualname": "GJFeatureCollection.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.GJFeatureCollection.to_objectlist", "modulename": "metacity.io.geojson.parser", "qualname": "GJFeatureCollection.to_objectlist", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.parse_point", "modulename": "metacity.io.geojson.parser", "qualname": "parse_point", "type": "function", "doc": "<p></p>\n", "signature": "(data)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.parse_multipoint", "modulename": "metacity.io.geojson.parser", "qualname": "parse_multipoint", "type": "function", "doc": "<p></p>\n", "signature": "(data)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.parse_line", "modulename": "metacity.io.geojson.parser", "qualname": "parse_line", "type": "function", "doc": "<p></p>\n", "signature": "(data)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.parse_multiline", "modulename": "metacity.io.geojson.parser", "qualname": "parse_multiline", "type": "function", "doc": "<p></p>\n", "signature": "(data)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.parse_polygon", "modulename": "metacity.io.geojson.parser", "qualname": "parse_polygon", "type": "function", "doc": "<p></p>\n", "signature": "(data)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.parse_multipolygon", "modulename": "metacity.io.geojson.parser", "qualname": "parse_multipolygon", "type": "function", "doc": "<p></p>\n", "signature": "(data)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.parse_geometry_collection", "modulename": "metacity.io.geojson.parser", "qualname": "parse_geometry_collection", "type": "function", "doc": "<p></p>\n", "signature": "(data)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.parse_geometry", "modulename": "metacity.io.geojson.parser", "qualname": "parse_geometry", "type": "function", "doc": "<p></p>\n", "signature": "(data) -> Union[metacity.io.geojson.parser.GJGeometryObject, NoneType]", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.parse_feature", "modulename": "metacity.io.geojson.parser", "qualname": "parse_feature", "type": "function", "doc": "<p></p>\n", "signature": "(data) -> metacity.io.geojson.parser.GJFeature", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.parse_feature_collection", "modulename": "metacity.io.geojson.parser", "qualname": "parse_feature_collection", "type": "function", "doc": "<p></p>\n", "signature": "(data)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.feature_into_collection", "modulename": "metacity.io.geojson.parser", "qualname": "feature_into_collection", "type": "function", "doc": "<p></p>\n", "signature": "(feature)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.geometry_into_collection", "modulename": "metacity.io.geojson.parser", "qualname": "geometry_into_collection", "type": "function", "doc": "<p></p>\n", "signature": "(geometry)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.parse_any", "modulename": "metacity.io.geojson.parser", "qualname": "parse_any", "type": "function", "doc": "<p></p>\n", "signature": "(data)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.parse_data", "modulename": "metacity.io.geojson.parser", "qualname": "parse_data", "type": "function", "doc": "<p></p>\n", "signature": "(data)", "funcdef": "def"}, {"fullname": "metacity.io.geojson.parser.parse", "modulename": "metacity.io.geojson.parser", "qualname": "parse", "type": "function", "doc": "<p></p>\n", "signature": "(input_file: str)", "funcdef": "def"}, {"fullname": "metacity.io.obj", "modulename": "metacity.io.obj", "type": "module", "doc": "<p></p>\n"}, {"fullname": "metacity.io.obj.export_obj", "modulename": "metacity.io.obj", "qualname": "export_obj", "type": "function", "doc": "<p>Export objects to an OBJ file.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>output_file (str):</strong>  The file to export to.</li>\n<li><strong>objects (Iterable[Object]):</strong>  The objects to export.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>int: The number of vertices exported.</p>\n</blockquote>\n", "signature": "(\n    output_file: str,\n    objects: Iterable[metacity.datamodel.object.Object]\n)", "funcdef": "def"}, {"fullname": "metacity.io.parse", "modulename": "metacity.io.parse", "type": "module", "doc": "<p></p>\n"}, {"fullname": "metacity.io.parse.parse_json", "modulename": "metacity.io.parse", "qualname": "parse_json", "type": "function", "doc": "<p>Parse a GeoJSON file. All contents are transformed into Metacity objects, and returned as a list.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>input_file (str):</strong>  Path to the GeoJSON file.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>list: List of Metacity objects.</p>\n</blockquote>\n", "signature": "(input_file: str)", "funcdef": "def"}, {"fullname": "metacity.io.parse.parse_shapefile", "modulename": "metacity.io.parse", "qualname": "parse_shapefile", "type": "function", "doc": "<p>Parse a Shapefile. All contents are transformed into Metacity objects, and returned as a list.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>input_file (str):</strong>  Path to the Shapefile.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>list: List of Metacity objects.</p>\n</blockquote>\n", "signature": "(input_file: str)", "funcdef": "def"}, {"fullname": "metacity.io.parse.parse", "modulename": "metacity.io.parse", "qualname": "parse", "type": "function", "doc": "<p>Parse a file. All contents are transformed into Metacity objects, and returned as a list.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>input_file (str):</strong>  Path to the file.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>list: List of Metacity objects or None if the file could not be parsed.</p>\n</blockquote>\n", "signature": "(input_file: str)", "funcdef": "def"}, {"fullname": "metacity.io.parse.parse_tree", "modulename": "metacity.io.parse", "qualname": "parse_tree", "type": "function", "doc": "<p>Generator, parses a contents of a directory recursively. All contents are transformed \ninto Metacity objects, and returned as a list. Yields Metacity objects one by one.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>input_dir (str):</strong>  Path to the directory.</li>\n</ul>\n", "signature": "(input_dir: str)", "funcdef": "def"}, {"fullname": "metacity.io.shapefile", "modulename": "metacity.io.shapefile", "type": "module", "doc": "<p></p>\n"}, {"fullname": "metacity.io.shapefile.parser", "modulename": "metacity.io.shapefile.parser", "type": "module", "doc": "<p></p>\n"}, {"fullname": "metacity.io.shapefile.parser.parse", "modulename": "metacity.io.shapefile.parser", "qualname": "parse", "type": "function", "doc": "<p></p>\n", "signature": "(shp_file: str)", "funcdef": "def"}, {"fullname": "metacity.utils", "modulename": "metacity.utils", "type": "module", "doc": "<p></p>\n"}, {"fullname": "metacity.utils.bbox", "modulename": "metacity.utils.bbox", "type": "module", "doc": "<p></p>\n"}, {"fullname": "metacity.utils.bbox.empty_bbox", "modulename": "metacity.utils.bbox", "qualname": "empty_bbox", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "metacity.utils.bbox.vertices_bbox", "modulename": "metacity.utils.bbox", "qualname": "vertices_bbox", "type": "function", "doc": "<p></p>\n", "signature": "(vertices: numpy.ndarray)", "funcdef": "def"}, {"fullname": "metacity.utils.bbox.bboxes_bbox", "modulename": "metacity.utils.bbox", "qualname": "bboxes_bbox", "type": "function", "doc": "<p></p>\n", "signature": "(bboxes: List[numpy.ndarray])", "funcdef": "def"}, {"fullname": "metacity.utils.bbox.join_boxes", "modulename": "metacity.utils.bbox", "qualname": "join_boxes", "type": "function", "doc": "<p></p>\n", "signature": "(boxes)", "funcdef": "def"}, {"fullname": "metacity.utils.encoding", "modulename": "metacity.utils.encoding", "type": "module", "doc": "<p></p>\n"}, {"fullname": "metacity.utils.encoding.npfloat32_to_buffer", "modulename": "metacity.utils.encoding", "qualname": "npfloat32_to_buffer", "type": "function", "doc": "<p></p>\n", "signature": "(data)", "funcdef": "def"}, {"fullname": "metacity.utils.encoding.npint32_to_buffer", "modulename": "metacity.utils.encoding", "qualname": "npint32_to_buffer", "type": "function", "doc": "<p></p>\n", "signature": "(data)", "funcdef": "def"}, {"fullname": "metacity.utils.encoding.npuint8_to_buffer", "modulename": "metacity.utils.encoding", "qualname": "npuint8_to_buffer", "type": "function", "doc": "<p></p>\n", "signature": "(data)", "funcdef": "def"}, {"fullname": "metacity.utils.encoding.base64_to_type", "modulename": "metacity.utils.encoding", "qualname": "base64_to_type", "type": "function", "doc": "<p></p>\n", "signature": "(b64data, type)", "funcdef": "def"}, {"fullname": "metacity.utils.encoding.base64_to_float32", "modulename": "metacity.utils.encoding", "qualname": "base64_to_float32", "type": "function", "doc": "<p></p>\n", "signature": "(b64data)", "funcdef": "def"}, {"fullname": "metacity.utils.encoding.base64_to_int32", "modulename": "metacity.utils.encoding", "qualname": "base64_to_int32", "type": "function", "doc": "<p></p>\n", "signature": "(b64data)", "funcdef": "def"}, {"fullname": "metacity.utils.filesystem", "modulename": "metacity.utils.filesystem", "type": "module", "doc": "<p></p>\n"}, {"fullname": "metacity.utils.filesystem.filename", "modulename": "metacity.utils.filesystem", "qualname": "filename", "type": "function", "doc": "<p></p>\n", "signature": "(file_path)", "funcdef": "def"}, {"fullname": "metacity.utils.filesystem.create_dir_if_not_exists", "modulename": "metacity.utils.filesystem", "qualname": "create_dir_if_not_exists", "type": "function", "doc": "<p></p>\n", "signature": "(dir)", "funcdef": "def"}, {"fullname": "metacity.utils.filesystem.recreate_dir", "modulename": "metacity.utils.filesystem", "qualname": "recreate_dir", "type": "function", "doc": "<p></p>\n", "signature": "(dir)", "funcdef": "def"}, {"fullname": "metacity.utils.filesystem.file_exists", "modulename": "metacity.utils.filesystem", "qualname": "file_exists", "type": "function", "doc": "<p></p>\n", "signature": "(file)", "funcdef": "def"}, {"fullname": "metacity.utils.filesystem.list_subdirectories", "modulename": "metacity.utils.filesystem", "qualname": "list_subdirectories", "type": "function", "doc": "<p></p>\n", "signature": "(dir)", "funcdef": "def"}, {"fullname": "metacity.utils.filesystem.join_path", "modulename": "metacity.utils.filesystem", "qualname": "join_path", "type": "function", "doc": "<p></p>\n", "signature": "(path, *args)", "funcdef": "def"}, {"fullname": "metacity.utils.filesystem.rename", "modulename": "metacity.utils.filesystem", "qualname": "rename", "type": "function", "doc": "<p></p>\n", "signature": "(old, new)", "funcdef": "def"}, {"fullname": "metacity.utils.filesystem.readable", "modulename": "metacity.utils.filesystem", "qualname": "readable", "type": "function", "doc": "<p></p>\n", "signature": "(file)", "funcdef": "def"}, {"fullname": "metacity.utils.filesystem.writable", "modulename": "metacity.utils.filesystem", "qualname": "writable", "type": "function", "doc": "<p></p>\n", "signature": "(file)", "funcdef": "def"}, {"fullname": "metacity.utils.filesystem.delete_file", "modulename": "metacity.utils.filesystem", "qualname": "delete_file", "type": "function", "doc": "<p></p>\n", "signature": "(file)", "funcdef": "def"}, {"fullname": "metacity.utils.filesystem.delete_dir", "modulename": "metacity.utils.filesystem", "qualname": "delete_dir", "type": "function", "doc": "<p></p>\n", "signature": "(dir)", "funcdef": "def"}, {"fullname": "metacity.utils.filesystem.write_json", "modulename": "metacity.utils.filesystem", "qualname": "write_json", "type": "function", "doc": "<p></p>\n", "signature": "(filename, data)", "funcdef": "def"}, {"fullname": "metacity.utils.filesystem.read_json", "modulename": "metacity.utils.filesystem", "qualname": "read_json", "type": "function", "doc": "<p></p>\n", "signature": "(filename)", "funcdef": "def"}, {"fullname": "metacity.utils.filesystem.dir_from_path", "modulename": "metacity.utils.filesystem", "qualname": "dir_from_path", "type": "function", "doc": "<p></p>\n", "signature": "(path)", "funcdef": "def"}, {"fullname": "metacity.utils.filesystem.change_suffix", "modulename": "metacity.utils.filesystem", "qualname": "change_suffix", "type": "function", "doc": "<p></p>\n", "signature": "(path, suffix)", "funcdef": "def"}, {"fullname": "metacity.utils.filesystem.get_suffix", "modulename": "metacity.utils.filesystem", "qualname": "get_suffix", "type": "function", "doc": "<p></p>\n", "signature": "(path)", "funcdef": "def"}, {"fullname": "metacity.utils.filesystem.ERROR_INVALID_NAME", "modulename": "metacity.utils.filesystem", "qualname": "ERROR_INVALID_NAME", "type": "variable", "doc": "<p>Windows-specific error code indicating an invalid pathname.</p>\n\n<h6 id=\"see-also\">See Also</h6>\n\n<blockquote>\n  <p><a href=\"https://docs.microsoft.com/en-us/windows/win32/debug/system-error-codes--0-499-\">Official listing of all such codes.</a></p>\n</blockquote>\n", "default_value": " = 123"}, {"fullname": "metacity.utils.filesystem.is_pathname_valid", "modulename": "metacity.utils.filesystem", "qualname": "is_pathname_valid", "type": "function", "doc": "<p><code>True</code> if the passed pathname is a valid pathname for the current OS;\n<code>False</code> otherwise.</p>\n", "signature": "(pathname: str) -> bool", "funcdef": "def"}, {"fullname": "metacity.utils.filesystem.is_path_creatable", "modulename": "metacity.utils.filesystem", "qualname": "is_path_creatable", "type": "function", "doc": "<p><code>True</code> if the current user has sufficient permissions to create the passed\npathname; <code>False</code> otherwise.</p>\n", "signature": "(pathname: str) -> bool", "funcdef": "def"}, {"fullname": "metacity.utils.filesystem.is_path_exists_or_creatable", "modulename": "metacity.utils.filesystem", "qualname": "is_path_exists_or_creatable", "type": "function", "doc": "<p><code>True</code> if the passed pathname is a valid pathname for the current OS <em>and</em>\neither currently exists or is hypothetically creatable; <code>False</code> otherwise.</p>\n\n<p>This function is guaranteed to <em>never</em> raise exceptions.</p>\n", "signature": "(pathname: str) -> bool", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();