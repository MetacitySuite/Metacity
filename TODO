Project:
    ☐ Backend Metacity @7days
    ☐ Metacity PIPY @1day
    ☐ Frontend Metacity @3days

Side:
    ☐ Koupit lampičku do kanclu
    ✔ Anička - klíče a čip zařídit - KUBA @done(21-10-21 18:56)

Backend Metacity: 
    ✔ Serializace @done(21-10-11 10:09)
        - @link:https://github.com/nlohmann/json
        - @link:https://github.com/pybind/pybind11_json
    ✔ Deserializace @done(21-10-11 10:09)
        - analogicky jako serializace
    ✔ Triangulace @started(21-10-11 11:49) @done(21-10-11 17:26) @lasted(5h37m38s)
        - cgal lze, ale zbytečně komplikované @link:https://doc.cgal.org/latest/Triangulation_2/index.html#title23 
        - prakticky použitelné @link:https://github.com/mapbox/earcut.hpp
        - výpočet vyžaduje cgal - bude potřeba nainstalovat na kompu, kde poběží, případně přidat do závislostí... 
        - @link:https://www.cgal.org/download/
        - @link:https://doc.cgal.org/latest/Polygon_mesh_processing/index.html#PMPNormalComp
        - alt:
            ✔ převést polygony na polygon mesh @done(21-10-11 14:29)
            ✔ najít normály @done(21-10-11 14:29)
            ✔ projekce do 2D podle normály - provedeno pomocí plane projection @done(21-10-11 17:27)
            ✔ triangulace pomocí mapboxu @done(21-10-11 17:27)
    ✔ Ověřit, jestli add face v cgalu nevrací index - dalo by se využít k hromadnému zpracování @done(21-10-11 20:49)
        - ověřeno, upraveno, takže alokace meshe před triangulací je provedena najednou
        - někdy to vrací divné face ID... ale ty jsou platné taky.
        - přidán check pro zpracování, aby se nepřidávaly null faces
    ✔ Transformace bodů do vertexů @done(21-10-12 13:30)
    ✔ Transformace linek do vertexů @done(21-10-12 13:30)
    ✔ Třídění do dlaždic - dělení geometrie podle pravidelné mřížky, uložení do samostatných objektů, přidání objectid (stavba gridu) @started(21-10-12 14:41) @done(21-10-14 12:07) @lasted(1d21h26m7s)
         - co když neznám na začátku všechna data? - lepší předpokládat hustá data, kde v každé buňce něco je vzhledem k charakteru vstupních dat
         - předpoklad: na začátku znám všechna data pro která budu stavět
         - pro to, abych zjistil rozsah dat, musím všechna data projít
         - ideál by bylo mít pevně stanovený počátek a dělení od daného počátku, resp kódování tím pádem mít hybrid hustého a řídkého zobrazení
         - umožní to skládat vrstvy na sebe snadno?
        Postup:
            ✔ 0. vyrob prázdný grid @done(21-10-12 16:02)
            ✔ 1. object dostane grid @done(21-10-12 16:40)
            ✔ 2. object projde primitiva a ta rozřeže dle gridu - dle bounding boxu? - dle rozměrů gridu @done(21-10-14 09:24)
                ✔ body @done(21-10-13 22:09)
                ✔ linky @done(21-10-13 22:09) - optimalizovano 
                ✔ trojuhelniky @done(21-10-14 09:23) - tohle je nakonec udelane tak jako v python demu, protoze jedina alternative byly arrangmenty... too complex ig
            ✔ 3. tyto rozřezané kousky předá gridu @done(21-10-14 12:07)
            ✔ 4. ten si je zařadí na správné místo do cache @done(21-10-14 12:07)
        Poznámky:
            - tile má tedy export cache do n souborů po k objektech a 1 soubor finální
            - adresace objektů v cache - lze uložit jako json, ale mohlo by být neefektivní, alternativy ale budou vyžadovat lineární průchod, jelikož ale není vyžadována funkcionalita mazání, nemělo by být tak moc problematické
            - co musí být rychle u gridu: 
                - rozřezaní elementů
                - spojování
        Z pohledu gridu:
            - vytvořit prázdný
            - načíst z disku
            - info pro primitivum kde řezat - tile size?
            - přidání primitiva (zařazení)
            - build z cache
    ✔ Export cache na disk do dlaždic @done(21-10-15 17:40)
        ✔ 5  pro každou tile se grid exportuje na disk @done(21-10-15 17:40)
            - vyžaduje doplnění ID pro objekty, musí být uloženo přímo u geometrie - je třeba připojit určitou formu atributů pro vertexy/elementy
            - atributy: pro elementy, pro vertexy - elementem se myslí čára, polygon, bod, vertexem se myslí jeden vertex ve vertex bufferu
            - atributy před provedením transformace - jsou atributy pro elementy
            - atributy po transformaci - jsou atributy pro vertexy
            - na disk se ukládá geometrie před transformací, po transformaci je uloženo v cache dlaždic (rozsekáno)
            - pokud chci mapovat 2 vrstvy na sebe - z cache se načtou Simple primitiva s atributy, ty se pak mapují na sebe
        ✔ 6. grid se vyexportuje na disk @done(21-10-15 17:40)
        ✔ 7. paměťová optimalizace - takhle budou všechny dlaždice v paměti, cache v předchozí verzi ukládala každé dlaždici soubor na objekt, což je nepoužitelné. Každá dlaždic může mít ale limitovaný počet otevřených objektů, tedy např. rozlišení 30 x 30 x 100 objektů x 10 kB = 878 MB v paměti, což jde @done(21-10-15 17:40)
        ✔ 8. po dozpracování se projde cache pro každou dlaždici a uloží se samostatně do jednoho souboru @done(21-10-15 17:40)
    ✔ Refactoring setů - dalo by se zjednodušit... @done(21-10-15 17:40)
    ✔ Ořez dle polygonální sítě @done(21-10-17 17:55)
        Co chci:
            1. mapování NA SimpleMultiPolygon dlaždici - mapování 2D na 3D
            2. mapování proxy - mám nějakou geometrii a tu chci otagovat jako padne do 2D dat

            |                      |    |
            |  co obarvuju         |    | SimpleMultiPoint    SimpleMultiLine     SimpleMultiPolygon
            |  podle čeho obarvuju |    |                                         2D          3D
            |----------------------|----|----------------------------------------------------------------
            |  SimpleMultiPoint    |    | --                  --                  --          --
            |  SimpleMultiLine     |    | --                  --                  --          --
            |  SimpleMultiPolygon  | 2D | yes                 yes                 yes         yes
            |                      | 3D | yes                 yes                 <- transformed to 2D yes
            |                      |    |

            proxy - vstup je řezán dle layoutu "Na" a otagován

        pro input SimpleMultiPolygon:
            0. postav DS nad podle čeho obarvuju
            1. pro každý triangle který chci obarvit najdi trojúhelníky podle kterých obarvit (měl by být jen jeden) - tady výšku vůbec neřeš
            2. najdi průniky
            3. obarvi a ulož (mapování výšky nebude implementováno)
        
        pro SimpleMultiLine:
            0. postav DS nad podle čeho chci obarvit
            1. pro každou linku najdi podle čeho obarvit
            2. nařež
            3. obarvi a ulož NEBO mapuj výšku
            
            namapování Z bude samostatná operace s analogickým postupem - nejprve se nařeže podle sítě a pak pomocí raycastingu se najde topmost

        pro SimpleMultiPoint:
            1. postav DS nad podle čeho chci obarvit
            2. pro každý bodík najdi triangle
            3. obarvi a ulož NEBO mapuj výšku 

        pro zadaný range (2D) najdi všechno co do této range padne
            KD-stromy - optimální pro search, ale tri musí být reprezentován více než jednou, takže vyžaduje check zde už jsme nezpracoval
            R-tree - https://dl.acm.org/doi/abs/10.1145/288692.288723  
        
        body:
            se vyrosi jen jako rayshooting, all good
        linky:
            prunik trojuhelniku a 3Dcka
        
        trojuhelniky:
            najdes prunik s trojuhelnikem - taddy to bude fungovat jen kdyz ten jeden bude 2D a nebude se tam nic protinat... prakticky potrebuju namapovat 2D dataset na 3D
            mozna na to jit fakt debilne, kdyz se tam budou trojuhelniky prekryvat, tak to tak musim vzit - jako kdyby byly dve parcely pres sebe

        //pro interpolaci linek - budou se interpolovat všechny atrbuty? - mám zatím jen využití pro linky, takže asi nemá smysl dělat něco extra obecného...

        - u mapování linek a bodů 3D se musí mapovat na nejhořejší trojúhelník - takže nějaký raycasting?
        - pomocí CGAL intersect pro trojúhelníky @link:https://doc.cgal.org/latest/Kernel_23/group__intersection__linear__grp.html
        - bude potřeba promítnout 3D data do 2D, pak najít průnik, pak zpětně dopočítat 3D souřadnice
        - dá se provádět na mřížce
        - stavba pravidelné mřížky pro skupinu meshe
            - princip: mám sadu objektů (points, lines, facets) a chci je rozházet do mřížky
            - query bude vypadat jako trojúhelník - chci všechno co do něj padne - dalo by se zjednodušit na obdélník? - dalo
            - v mřížce logicky budou trojúhelníky vícekrát, pokud budou ležet ve více buňkách, musí se tedy kontrolovat, zda jsem je už navštívil - jak efektivně?

    ☐ Parsování XMP po matsimu - přidání časové složky, nové primitivum - anička?
        - nové primitivum pro linky, simple primitivum se bude dát reuse 
    ☐ Upravit IO pro nové geometry api
        ✔ 1. geojson @done(21-10-18 11:26)
        ✔ 2. shapefile @done(21-10-18 11:26)
        3. cityjson
    ✔ Otestovat tvorbu gridu @done(21-10-20 12:38)
        ✔ stavba gridu @done(21-10-20 12:38)
        ✔ export do stl, nebo nějaký jiný způsob ověření, že ty modely dávají smysl @done(21-10-20 12:38)
    ☐ Otestovat mapování 2D na 3D
        - body
        ✔ linky @done(21-10-20 12:38) - otestováno na síti ulic prahy
        ✔ trojuhelniky @done(21-10-20 17:31)

Metacity PIPY:
    ✔ Deploy stabilní verze backendu @done(21-10-21 18:56)
    
Frontend Metacity:
    ✔ Přidání projektu @done(21-10-22 09:45)
    ✔ Nahrání zdorjových souborů @done(21-10-22 09:45)
        - nefunguje prozatím cityjson, protože ale nemáme žádná data tady v tomto formátu, není to priorita 
    ✔ Souhrný json pro projekt @done(21-10-25 18:40)
        ✔ ten si stáhne vizualizér a bude vědět jaké soubory kde hledat, případně kdy je načítat @done(21-10-25 18:40)
    ✔ Sáhnout souhrn pro projekt a naparsovat data @done(21-10-25 18:40)
    ☐ UI/UX stuff
        ✔ úprava orbital controls na styl google earth @done(21-10-26 12:14)
    ☐ Zobrazení gridu
        ☐ Zobrazení bodů
        ☐ Zobrazení linek
            ✔ samotné linky @done(21-10-27 19:37)
            - picking
        ✔ Zobrazení polygonů @done(21-10-25 18:40)
        ☐ Zobrazení proxy
    ☐ Vizuální kraviny
        ✔ stíny @done(21-10-25 18:41)
            - je u nich problém s biasem, bude potřeba trochu lépe nastavit...
        - UI pro skrytí/zobrazení vrstvy
        ✔ vlastní shader pro obarvení dle ID @done(21-10-26 18:13)
        - UI pro přiřazení metadato - barva
        - linky budou mít nějakou tlušťku
            ✔ globální tloušťka @done(21-10-27 19:37)
            ☐ parametrizovatelná tloušťka
    ✔ Vybírání (vlastní shader) @done(21-10-26 18:13)
    ☐ Metadata
        - stáhnout metadata 
        - postavit nad nimi nějakou datovou strukturu, aby se to dalo dobře prohlížet
        - přiřazení barviček různým kategoriím
    ☐ UI pro mapování 2D na 3D - párování a overlay
    ☐ Obarvování dle dvojice OID
    ☐ Prohlížení metadat nějak hromadně?

=================================================================================================================

Později před odevzdáním:
    ☐ Otestovat, dopsat testy?
    ☐ Refaktorování!!
    
Potenciální Issues:
    ☐ Nebude fungovat indexování okolo nuly, všechno to spadne do jedné dlaždice, je to ok?
    ☐ Hraniční trojúhelníky se špatně zařazují, pokud došlo k tenkému rozřezu?

Future:
    ☐ Přepsat triangulace atd do jednoho stylu a používat jednotnou strukturu
    ☐ Transformace datasetů podle CRS

Poznámky:
    - https://github.com/tobywf/python-ext-asan - debug na linuxu
    Statistiky:
        Terrain - 4502183 objektů - 450 souborů
        Buildings - 5362859 objektů
        na zpracování cca 2GB dat je potřeba cca 200MB paměti
    - multipatch reprezentuje budovy jako celek bez identifikace jednotlivých částí budov, polygonZ je reprezentuje po částech s přiadným atributem popisující TYP (popis je česky)

    
    
Statistiky pro dlaždice z tvorby overlay pro budoy a využití
size 35928
avg  16.84
max  193
size 6560
avg  10.2825
max  93
size 30369
avg  9.95568
max  136
size 23161
avg  16.8149
max  115
size 10262
avg  20.2627
max  89
size 38322
avg  15.4158
max  254
size 31992
avg  23.6549
max  188
size 654
avg  65.7508
max  122
size 9822
avg  14.2739
max  201
size 1280
avg  17.4352
max  48
size 11101
avg  17.7522
max  254
size 1946
avg  10.0293
max  67
size 16317
avg  24.1823
max  118
size 82008
avg  17.4284
max  1155
size 1887
avg  20.9491
max  64
size 14394
avg  11.7698
max  290
size 55596
avg  16.7355
max  191
size 20536
avg  29.772
max  290
size 21198
avg  17.6797
max  86
size 92
avg  19.4565
max  38
size 38126
avg  17.3402
max  243
size 72104
avg  19.3972
max  602
size 34
avg  9.55882
max  14
size 33151
avg  19.7237
max  260
size 9450
avg  12.6732
max  82
size 35082
avg  19.4361
max  147
size 12737
avg  13.4799
max  62
size 8197
avg  17.4697
max  171
size 45166
avg  13.2502
max  224
size 8553
avg  19.7496
max  139
size 49959
avg  18.641
max  143
size 9166
avg  16.7642
max  79
size 10098
avg  15.6843
max  79
size 29358
avg  14.3347
max  100
size 54
avg  12.037
max  25
size 41462
avg  26.4989
max  161
size 6089
avg  15.8854
max  136
size 22073
avg  24.7045
max  537
size 74298
avg  15.9282
max  118
size 477
avg  8.74214
max  39
size 4597
avg  20.132
max  246
size 5974
avg  15.5616
max  77
size 62338
avg  16.0446
max  90
size 24293
avg  26.3303
max  250
size 24400
avg  15.2123
max  289
size 41013
avg  12.5886
max  162
size 27479
avg  17.5148
max  91
size 22132
avg  18.4128
max  132
size 25552
avg  20.7426
max  206
size 148
avg  18.3311
max  52
size 59326
avg  18.2366
max  243
size 6336
avg  10.0197
max  110
size 16531
avg  17.2895
max  200
size 42830
avg  25.9953
max  249
size 35189
avg  17.8552
max  410
size 16037
avg  15.5636
max  96
size 129
avg  5.05426
max  10
size 10040
avg  29.2875
max  117
size 2184
avg  12.8072
max  44
size 3125
avg  12.2774
max  67
size 18537
avg  25.1561
max  118
size 51336
avg  15.0186
max  193
size 27515
avg  33.7052
max  1297
size 208373
avg  20.5007
max  503
size 56896
avg  23.4217
max  136
size 150377
avg  18.6637
max  292
