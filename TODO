Project:
    ☐ Backend Metacity @7days
    ☐ Metacity PIPY @1day
    ☐ Frontend Metacity @3days

Side:
    ☐ Koupit lampičku do kanclu

Backend Metacity: 
    ✔ Serializace @done(21-10-11 10:09)
        - @link:https://github.com/nlohmann/json
        - @link:https://github.com/pybind/pybind11_json
    ✔ Deserializace @done(21-10-11 10:09)
        - analogicky jako serializace
    ✔ Triangulace @started(21-10-11 11:49) @done(21-10-11 17:26) @lasted(5h37m38s)
        - cgal lze, ale zbytečně komplikované @link:https://doc.cgal.org/latest/Triangulation_2/index.html#title23 
        - prakticky použitelné @link:https://github.com/mapbox/earcut.hpp
        - výpočet vyžaduje cgal - bude potřeba nainstalovat na kompu, kde poběží, případně přidat do závislostí... 
        - @link:https://www.cgal.org/download/
        - @link:https://doc.cgal.org/latest/Polygon_mesh_processing/index.html#PMPNormalComp
        - alt:
            ✔ převést polygony na polygon mesh @done(21-10-11 14:29)
            ✔ najít normály @done(21-10-11 14:29)
            ✔ projekce do 2D podle normály - provedeno pomocí plane projection @done(21-10-11 17:27)
            ✔ triangulace pomocí mapboxu @done(21-10-11 17:27)
    ✔ Ověřit, jestli add face v cgalu nevrací index - dalo by se využít k hromadnému zpracování @done(21-10-11 20:49)
        - ověřeno, upraveno, takže alokace meshe před triangulací je provedena najednou
        - někdy to vrací divné face ID... ale ty jsou platné taky.
        - přidán check pro zpracování, aby se nepřidávaly null faces
    ✔ Transformace bodů do vertexů @done(21-10-12 13:30)
    ✔ Transformace linek do vertexů @done(21-10-12 13:30)
    ✔ Třídění do dlaždic - dělení geometrie podle pravidelné mřížky, uložení do samostatných objektů, přidání objectid (stavba gridu) @started(21-10-12 14:41) @done(21-10-14 12:07) @lasted(1d21h26m7s)
         - co když neznám na začátku všechna data? - lepší předpokládat hustá data, kde v každé buňce něco je vzhledem k charakteru vstupních dat
         - předpoklad: na začátku znám všechna data pro která budu stavět
         - pro to, abych zjistil rozsah dat, musím všechna data projít
         - ideál by bylo mít pevně stanovený počátek a dělení od daného počátku, resp kódování tím pádem mít hybrid hustého a řídkého zobrazení
         - umožní to skládat vrstvy na sebe snadno?
        Postup:
            ✔ 0. vyrob prázdný grid @done(21-10-12 16:02)
            ✔ 1. object dostane grid @done(21-10-12 16:40)
            ✔ 2. object projde primitiva a ta rozřeže dle gridu - dle bounding boxu? - dle rozměrů gridu @done(21-10-14 09:24)
                ✔ body @done(21-10-13 22:09)
                ✔ linky @done(21-10-13 22:09) - optimalizovano 
                ✔ trojuhelniky @done(21-10-14 09:23) - tohle je nakonec udelane tak jako v python demu, protoze jedina alternative byly arrangmenty... too complex ig
            ✔ 3. tyto rozřezané kousky předá gridu @done(21-10-14 12:07)
            ✔ 4. ten si je zařadí na správné místo do cache @done(21-10-14 12:07)
        Poznámky:
            - tile má tedy export cache do n souborů po k objektech a 1 soubor finální
            - adresace objektů v cache - lze uložit jako json, ale mohlo by být neefektivní, alternativy ale budou vyžadovat lineární průchod, jelikož ale není vyžadována funkcionalita mazání, nemělo by být tak moc problematické
            - co musí být rychle u gridu: 
                - rozřezaní elementů
                - spojování
        Z pohledu gridu:
            - vytvořit prázdný
            - načíst z disku
            - info pro primitivum kde řezat - tile size?
            - přidání primitiva (zařazení)
            - build z cache
    ✔ Export cache na disk do dlaždic @done(21-10-15 17:40)
        ✔ 5  pro každou tile se grid exportuje na disk @done(21-10-15 17:40)
            - vyžaduje doplnění ID pro objekty, musí být uloženo přímo u geometrie - je třeba připojit určitou formu atributů pro vertexy/elementy
            - atributy: pro elementy, pro vertexy - elementem se myslí čára, polygon, bod, vertexem se myslí jeden vertex ve vertex bufferu
            - atributy před provedením transformace - jsou atributy pro elementy
            - atributy po transformaci - jsou atributy pro vertexy
            - na disk se ukládá geometrie před transformací, po transformaci je uloženo v cache dlaždic (rozsekáno)
            - pokud chci mapovat 2 vrstvy na sebe - z cache se načtou Simple primitiva s atributy, ty se pak mapují na sebe
        ✔ 6. grid se vyexportuje na disk @done(21-10-15 17:40)
        ✔ 7. paměťová optimalizace - takhle budou všechny dlaždice v paměti, cache v předchozí verzi ukládala každé dlaždici soubor na objekt, což je nepoužitelné. Každá dlaždic může mít ale limitovaný počet otevřených objektů, tedy např. rozlišení 30 x 30 x 100 objektů x 10 kB = 878 MB v paměti, což jde @done(21-10-15 17:40)
        ✔ 8. po dozpracování se projde cache pro každou dlaždici a uloží se samostatně do jednoho souboru @done(21-10-15 17:40)
    ✔ Refactoring setů - dalo by se zjednodušit... @done(21-10-15 17:40)
    ✔ Ořez dle polygonální sítě @done(21-10-17 17:55)
        Co chci:
            1. mapování NA SimpleMultiPolygon dlaždici - mapování 2D na 3D
            2. mapování proxy - mám nějakou geometrii a tu chci otagovat jako padne do 2D dat

            |                      |    |
            |  co obarvuju         |    | SimpleMultiPoint    SimpleMultiLine     SimpleMultiPolygon
            |  podle čeho obarvuju |    |                                         2D          3D
            |----------------------|----|----------------------------------------------------------------
            |  SimpleMultiPoint    |    | --                  --                  --          --
            |  SimpleMultiLine     |    | --                  --                  --          --
            |  SimpleMultiPolygon  | 2D | yes                 yes                 yes         yes
            |                      | 3D | yes                 yes                 <- transformed to 2D yes
            |                      |    |

            proxy - vstup je řezán dle layoutu "Na" a otagován

        pro input SimpleMultiPolygon:
            0. postav DS nad podle čeho obarvuju
            1. pro každý triangle který chci obarvit najdi trojúhelníky podle kterých obarvit (měl by být jen jeden) - tady výšku vůbec neřeš
            2. najdi průniky
            3. obarvi a ulož (mapování výšky nebude implementováno)
        
        pro SimpleMultiLine:
            0. postav DS nad podle čeho chci obarvit
            1. pro každou linku najdi podle čeho obarvit
            2. nařež
            3. obarvi a ulož NEBO mapuj výšku
            
            namapování Z bude samostatná operace s analogickým postupem - nejprve se nařeže podle sítě a pak pomocí raycastingu se najde topmost

        pro SimpleMultiPoint:
            1. postav DS nad podle čeho chci obarvit
            2. pro každý bodík najdi triangle
            3. obarvi a ulož NEBO mapuj výšku 

        pro zadaný range (2D) najdi všechno co do této range padne
            KD-stromy - optimální pro search, ale tri musí být reprezentován více než jednou, takže vyžaduje check zde už jsme nezpracoval
            R-tree - https://dl.acm.org/doi/abs/10.1145/288692.288723  
        
        body:
            se vyrosi jen jako rayshooting, all good
        linky:
            prunik trojuhelniku a 3Dcka
        
        trojuhelniky:
            najdes prunik s trojuhelnikem - taddy to bude fungovat jen kdyz ten jeden bude 2D a nebude se tam nic protinat... prakticky potrebuju namapovat 2D dataset na 3D
            mozna na to jit fakt debilne, kdyz se tam budou trojuhelniky prekryvat, tak to tak musim vzit - jako kdyby byly dve parcely pres sebe

        //pro interpolaci linek - budou se interpolovat všechny atrbuty? - mám zatím jen využití pro linky, takže asi nemá smysl dělat něco extra obecného...

        - u mapování linek a bodů 3D se musí mapovat na nejhořejší trojúhelník - takže nějaký raycasting?
        - pomocí CGAL intersect pro trojúhelníky @link:https://doc.cgal.org/latest/Kernel_23/group__intersection__linear__grp.html
        - bude potřeba promítnout 3D data do 2D, pak najít průnik, pak zpětně dopočítat 3D souřadnice
        - dá se provádět na mřížce
        - stavba pravidelné mřížky pro skupinu meshe
            - princip: mám sadu objektů (points, lines, facets) a chci je rozházet do mřížky
            - query bude vypadat jako trojúhelník - chci všechno co do něj padne - dalo by se zjednodušit na obdélník? - dalo
            - v mřížce logicky budou trojúhelníky vícekrát, pokud budou ležet ve více buňkách, musí se tedy kontrolovat, zda jsem je už navštívil - jak efektivně?

    ☐ Parsování XMP po matsimu - přidání časové složky, nové primitivum
        - nové primitivum pro linky, simple primitivum se bude dát reuse 
    ☐ Upravit IO pro nové geometry api
        1. geojson
        2. shapefile
        3. cityjson
    ☐ Otestovat, dopsat testy?

Metacity PIPY:
    ☐ Deploy stabilní verze backendu
    ☐ Sepsat seznam potřebných funkcionalit 
    ☐ Ověřit, jestli funkcionality jsou
    ☐ Doplnit funkcionality chybějící

Frontend Metacity:
    ☐ Načítání dlaždic
    ☐ Rozmyslet zbytek vizualizace

Poznámky:
    https://github.com/tobywf/python-ext-asan - debug na linuxu